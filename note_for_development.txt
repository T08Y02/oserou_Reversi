#note
ソースコードを修正・開発したい人用の記述が主となります。

#index

 (概要) line 13
 (コード解説)
    oserou_log_learnフォルダ内のファイル : line 49
    data_learnフォルダ内のファイル : line 115
    data_reset.py : line 137
    oserou_vscpu.py : line 140
    oserou_forlearn.py : line 285
    
    
#abstract

 ファイル構造：
  oserou >> data_learn 
            >>　line_{}.csv  ({}には1~38の整数値)

         >> oserou_log_learn
            >>  oserou_log_learn_incdec{}.csv  ({}には整数値、デフォルトでは1~8)
        
         >> data_reset.py

         >> oserou_vscpu.py

         >> oserou_forlearn.py

data_learn : オセロの盤面についての学習データを行・列別にデータ処理して格納するフォルダ
    line_{}.csv : 行・列別の学習データ(csvファイル)。過去に学習した全てのデータを処理・格納している。

oserou_log_learn : オセロの盤面についての学習データを学習に用いた試合ごとに格納するフォルダ
    oserou_log_learn_incdec{}.csv : 試合別の学習データ(csvファイル)。学習の際に更新される。
data_reset.py : 実行することで学習内容を初期化できます。具体的には、data_learn内のファイルを初期化します。
oserou_vscpu.py : 実行することでcpuとオセロをプレイできます。引数は int a です。
                    　ファイル実行後に　"time control:"という文が出力されるので、プレイヤーの
                    　一手あたりの待ち時間として設定したい値を、キーボード等を用いて整数値半角で入力してください。
                      <実行コード例> python3 oserou_vscpu.py   (ここまで一旦入力して実行)
                      　　　　　　　　time control: 5　　　　　　 (数字部分のみ入力して実行)
oserou_forlearn.py : 実行することでcpuにオセロを学習させます。引数は int suuji　です。
                    ファイル実行後に　"save file number:"という文が出力されるので、学習したデータを格納する
                        　ファイル　oserou_log_learn_incdec{}.csv のファイル名の{}部分に設定したい数値を、
                        　キーボード等を用いて整数値半角で入力してください。
                    　<実行コード例>　python3 oserou_vscpu.py   (ここまで一旦入力して実行)
                      　　　　　　　　save file number: 5　　　　　　 (数字部分のみ入力して実行)

#コード解説
(oserou_log_learnフォルダ内のファイル)
oserou_log_learn_incdec{}.csv, {}には整数値、デフォルトでは1~8　が格納されている。
これらのcsvファイルは要素intの二次元配列であり、39行ごとにブロック化されている。
各ブロックはその時点での経過したターン数と盤面を格納しており、後手番についてのみ記録される。
以下、各ブロックにおけるn行目を line n(mod 39)と呼称する。各ブロックの39行目は簡単のためline 39(mod 39)と呼称する。
    (ブロックの構造)
    line 1(mod 39) : 要素数1の一次元配列。その盤面が生じた時点での、プレイヤーまたはcpuがパスしたターンを除いた
    　　　　　　　　　　経過ターン数を格納する。
    line 2(mod 39) ~ line 39(mod 39) ：　要素数可変の一次元配列。一番目の要素は0で固定であり、2 ~ 39それぞれが
    盤面のいずれかの行/列/ななめの列に対応している。

        (重要)　各行/列/ななめの列の格納方法
        <行・列の場合>
        1. 8つの石を、石がない状態を0, 黒石を1, 白石を2として要素数8の配列とみなす。
        　左から右、上から下の方向に記録する。        　　
          ex ) 空白白黒空黒黒白　→ [0, 2, 2, 1, 0, 1, 1, 2]
        2. 先ほどの配列について、隣接する要素が同じ部分はひとつの要素とみなす。
        　ex) [0, 2, 2, 1, 0, 1, 1, 2] → [0, 2, 1, 0, 1, 2]
        3. 隣接している要素同士の変化を記録する。
        　(0,1) = 1, (0,2) = 2, (1,0) = -1, (1, 2) = 3, (2,0) = -2, (2,1) = -3
        　ex) [0, 2, 1, 0, 1, 2] → [(0,2) , (2,1), (1,0), (0,1), (1,2)]
                                 → [2, -3, -1, 1, 3]
        <ななめも含む場合>
        以下の表のようにk = 1~38の数字を各行, 列, 斜めの列に割り振る。 
        左から右、上から下、左上から右下、右上から左下の方向に格納。
        k番目の行をline k+1 (mod 39) の2番目以降の要素に格納する。
        マスの数が2以下のななめの列は面倒だったので番号を割り振っていない。

    　    12345678   22 2726252423               282930313233
    　9   oooooooo   21 o o o o o o o o    o o o o o o o o 38
    　10  oooooooo   20 o o o o o o o o    o o o o o o o o 37
    　11  oooooooo   19 o o o o o o o o    o o o o o o o o 36
    　12  oooooooo   18 o o o o o o o o    o o o o o o o o 35
    　13  oooooooo   17 o o o o o o o o    o o o o o o o o 34
    　14  oooooooo      o o o o o o o o    o o o o o o o o
    　15  oooooooo      o o o o o o o o    o o o o o o o o
    　16  oooooooo      o o o o o o o o    o o o o o o o o
    以降、この格納方法を「列の増減を格納する」と表現する。

手番ごとに末尾に追加する形でこの39行のブロックが追記されていくため、
oserou_log_learn_incdec{}.csvファイルの構造は

2
0, 2, -2
...(37行省略)...
0, 3, -3
4
0, 1, -1
...(31ブロック省略)...

60
0, 2, -2
...(37行省略)...
0, 1, -1
1    (ここから次の試合)
...

となる。

oserou_log_learnフォルダ内のデータはdata_learnフォルダ内に学習データを格納するための一時保管場所、
ならびに記譜の再現や学習が適切に行われているか確認するために用いることを想定している。
oserou_forlearn.py の解説で詳細を述べるが、一試行あたり最大10試合の盤面データ(8000~12000行程度)を格納する。
構造上は格納する試合数に制限はないが、学習の際にはdata_learnフォルダ内のデータのみを参照するので
学習に使用した試合データを記録する必要がない場合にはoserou_log_learnフォルダ内に大量の試合データを
格納しておくメリットはない。

(data_learnフォルダ内のファイル)
line_{}.csv, {}には整数値、1~38で固定　が格納されている。
これらのcsvファイルは要素intの二次元配列であり、line_k.csvは(oserou_log_learnフォルダ内のファイル)で前述した
行/列/ななめの列の記録方法を用いて、同項目で盤の各行/列/ななめの列に割り振った番号のうちk番目の列についての
学習データを格納している。line_k.csvの各行は、学習段階でk番目の列に出現した全ての石の配置のパターンとその出現回数を
記録している。各行の一要素目が出現回数(初めて出現した場合は0を記録する)、二要素目以降が配置パターンである。
ex) line_k.csv　の構造が
    [[0, -1],
     [2, -1, 1, 3],
     [3, -1, 2, 1] ]
    となっている場合、全ての学習した試合を通じてk番目の列には石の配置が[-1]のパターンが1回、 石の配置が[-1, 1, 3]のパターンが3回、
    石の配置が[-1, 2, 1]のパターンが4回出現したことを表している。

学習の際は、
<oserou_forlearn.pyを実行>
     1. cpu同士で試合を10回シミュレーションし、後手番が勝利した試合についてのみ、後手番の時点で出現した盤面を
     　　oserou_log_learn_incdec{}.csv　に格納
     2. 1で得られた最大10試合分の盤面データを、各行/列/ななめの列ごとに line_{}.csv に分類し格納する。
という流れになるので、data_learn内には必ず1~38までの全てのインデックスについてline_{}.csvが存在する必要がある。
line_{}.csvを初期化する際は、1行2列の要素intの二次元配列[[0, -1]]となるように設定する必要がある。これ以外の初期値については
正常な動作を保証しない。

(data_reset.py)
入力引数は不要である。1~38までの全ての　line_{}.csv　を先ほど述べた初期値に書き換え、過去の学習内容を全て破棄することができる。

(oserou_vscpu.py)
関数の解説 : "<f> 返り値 = 関数名(入力引数) : 関数の解説" 
変数の解説 : "<v> (型)変数名: 変数の解説
というフォーマットに従って説明する。原則、上から順番に関数/変数を説明する。メインプログラム部分は末尾で解説しているので注意。

oserou_vscpu.py で使用するライブラリ：tkinter, csv, os, time, random, math

      retsu →
  g   o o ... o
  y   .       .
  o   .       .
  u   .       .
  ↓   o  ...  o

class Tkgui : オセロの盤面をtkinterを用いてウィンドウに表示するクラス。
    <f> void = init(self) : ウィンドウと変数の初期化
        <v> (bool) clk_ok: その時点においてクリック入力を受け取るかどうかを制御する変数。trueのときのみクリック入力を受け取る。
    <f> void = ban_image(self, ban) : 盤の状態を変数banで受け取り、その状態の盤をウィンドウに表示する関数
        <v> ban : オセロの盤面を記録する要素int の二次元配列。空白のマスは0、黒色のマスは1、白色のマスは2で表す。
            i行目j列目のマスの石の状態を ban[i][j] で表す。
    <f> void = click_upload(self, event) :  init内のself.canvas.bindで左クリックと関連づけられた関数。左クリックが入力されると
    　       呼び出される。ユーザのクリックした位置に赤色の石を表示する。
        <v> (global) (int) gyoudayo : クリックされた点のx座標を格納する
        <v> (global) (int) retudayo : クリックされた点のy座標を格納する
        <v> (CanvasID) ovallll : ユーザがクリック入力を行うまでの間、盤外左上に配置される赤い石のtkinterのウィンドウ上でのID
    <f> void = clkok(self) : 呼び出された時点でクリック入力を打ち切る
    <f> void = wait_click(self, a) : a * 1000　秒後にclkokを呼び出し、入力を打ち切る
        <v> (int) a : ユーザが設定したい待ち時間として入力したint 値を a として渡している。
<f> ban = osero_initialize(ban) : オセロの初期配置を二次元配列ban上に設定する　渡される元の配列banは全ての要素が0で初期化されている
<f> ban = ban_place(ban, gyou, retsu, color) : gyou 行 retsu 列に color で指定される石を配置するようにbanを更新する
    <v> (int) gyou : 0 ~ 7の整数値、盤上の行を表す
    <v> (int) retsu : 0 ~ 7の整数値、盤上の列を表す
    <v> (int) color : 1または2の整数値、1は黒石(先手番)で2は白石(後手番)
<f> ban = ban_reverse(ban, gyou, retsu) : gyou行retsu列目の石の色を反転させる
<f> ban = ban_reverse_onestone(an, gyou, retsu, color) : 
        gyou行retsu番目のマスの石を置いた場合に、挟まれた石をひっくり返した状態にbanを更新
<f> ban = ban_placestone(ban, gyou, retsu, color) : gyou行retsu列目のマスに対して、ban_placeとban_reverse_onestoneを
        実行することで、gyou行retsu列目のマスにcolorで指定される石を置き、盤上の残りの石を必要に応じてひっくり返すという機能を実現する
<f> score = score_initialize(vrhi, hi, mid, lw, vrlw) : 盤面に対する評価値のうち、盤上の石の位置に与えられる評価値の一覧を表す
        二次元配列score を返す。。
        たとえば、角のマスに石があると大きく有利なので、角のマスに石がある場合は高得点のvrhiを加算し、角のマスにアクセスできるマスに石を
        置いてしまうと次のターン 相手に角をとられてしまう可能性が高いため、そのようなマスに石がある場合には低い点数vrlwを加算するなど、
        各マスに対してその場所に石がある場合の得点を割り振っておく。
    <v> (int) vrhi, hi, mid, lw, vrlw : マスに割り振る得点(左から高い順を想定)。割り振り方はscore内容を書き換えることで変更する
        ※盤面評価値の都合上、評価値は1以上、また最大でも100までにすること(石を取れないマスやすでに石があるマスの評価値を-200000に設定し、
        評価値が負の場所には石を置くことを禁止することで石が置けるかどうかの判定をしているため　詳細な仕様は後述)
    <v> (2Dlist)score : 8行8列の二次元配列で、要素はint　盤面の各マスに石を置いた場合の評価値を表す　
        評価値の定め方は順次更新されてゆき、
<f> scoreall = score_count(ban, gyou, retsu, color) : 盤面banに対して、ban[gyou][retsu]に石を置いた場合に取れる相手の石の数を
        合算し、(int)scoreallとして返す
    <v> (int) before_c : 配置する側の石の色
    <v> (int) after_c : とられる側の石の色
    <v> (int) ue, migiue, migi, migisita, sita, hidarisita, hidari, hidariue : それぞれの方向に取れる石の数
<f> score = score_calc2(ban) : 使用していない(内容の詳細はoserou_forlearn.pyの解説を参照)
<f> score = score_calc1(ban) : 使用していない(内容の詳細はoserou_forlearn.pyの解説を参照)
<f> incdec2d = ban_incdec(teban, ban) : 盤の状態banについて、各行/列/ななめの列の増減を二次元配列incdecに格納する。
        列の増減の意味および格納方法は(oserou_log_learnフォルダ内のファイル)を参照。
    <v> (int) teban : その時点での経過ターン数を格納する整数値(1 ~ 原則60、パスがあると増加)。パスを行ったターンもカウントする
    <v> (2Dlist) incdec2d : 65行列数可変の二次元配列。一行目は要素数1で手番を格納し、二行目以降は一つ目の要素が0、それ以降の要素は
    　　　(oserou_log_learnフォルダ内のファイル)と同様に盤面を記録する。
<f> void = save_incdec2d(teban, ban, filename, data) : 試合を通じた盤面の記録を格納する二次元配列dataに、ターン数tebanの
        時点での盤面banをban_incdec関数を用いて記録した二次元配列を追加する
        ※現在の実装ではfilename は使用していないが、今後の開発のために残している。
    <v> (2Dlist)data : 試合を通じた盤面の記録を格納する二次元配列。65行ごとにブロック化され、前述した
<f> score = score_learning(ban, color) : banに示された盤面における、colorで指定される側(黒石 or 白石) の手番においてとりうる手と
    とその評価値を列挙し、各マスに石を置いた場合の盤面の評価値を二次元配列scoreに格納して返す
    score_initializeで各マスに対する初期値を付与 → すでに石があるマスには-200000点を加えて選択肢から排除 
    → score_count が正、すなわちその場所に石をおけば相手の石が最低一個は取れるマス(有効な位置)についてのみ、そのマスに石を置いた際に取れる
    相手の石の数をscore_countで求めて初期値に足す → 同様のマスに対してのみ、下に記すthisincdec2dを用いて学習データから得られる評価値を
    さらにscoreに乗算する　→ それ以外のマスには-200000点をscoreに加算して選択肢から除外(石を取れないマスには石を置けないルールなので)
    → 結果として、オセロの手として有効な位置については 
    マスの評価値 = {初期値(score_initialize) + 取れる石の数(score_count)} * 学習から得られる評価値 (thisincdec2dの合致度合い) > 0、
    有効ではない位置については score = ー200000 + 初期値 << 0 で定まる評価値が得られ、各マスに対する評価値を格納した二次元配列scoreが得られる。
    
    　
    <v> (2Dlist)kasou_ban : 8行8列の二次元配列、要素は全てint(0 or 1 or 2)。gyou行retsu列目のマスの石をcolorで指定される石に変更した
        と仮定した場合の盤面を格納する。gyou, retsuは石がまだ存在せず石が取れるマス(オセロの手として有効な位置)全てについて探索を行い、
        それぞれのgyou, retsuに対して仮想的な盤面kasou_banの評価値をscore[gyou][retsu]に格納していく。
    <v> (2Dlist) thisincdec2d : 8行可変長列の二次元配列、要素はint。gyou行retsu列にcolorで指定される石を置いたと仮定した場合の盤面の
        各列の増減を格納する。data_learnフォルダ内のcsvファイルを参照し、38列それぞれについて、同じ増減を持つ盤面が学習データのうち何度
        登場したかをファイルから読み出し(line{}.csv に対する各行の線形探索)、
        38列分の値の合計(より正確には各列の増減の出現回数の100の対数をとって小数点以下を切り上げて得られる整数値を元のscoreに乗算していく)
        を学習データに基づく評価値とする。学習段階で後手(cpu側)が勝った試合に出現した盤面の増減とその出現回数をdata_learnフォルダ内の
        csvファイルは記録しているので、勝った試合に多く出現している増減は有利な盤面に特徴的な増減である可能性が高いという推定のもとで
        盤面のスコアリングに用いている。対数の底が小さいほど全体のスコアリングに対する学習データの影響が大きくなる。
        計算方法やパラメタの値は適当なので改良の余地が大いにあると思われる。
        オセロの手として有効でない手についてのみスコアが負になるようにしたいので、スコアを乗算する部分はいじらない方が良い(そのためのlog)。
    <v> (string) filename2 : data_learnフォルダ内のcsvファイルに対して、列の番号を示すint値 kaiseki により指定される列に対応するcsv
        ファイルのファイル名を格納する。
<f> ban = cpu_placestone2(ban) : score_learningで得られた評価値の配列scoreをもとに、全てのマスについて左から右、上から下の順でscoreが
        最大値をとるマスを線形探索し、最大値を取るマスのうち最も左上にあるマスを最善手と解釈し、そのマスの座標を(bestscorex, bestscorey)
        に格納する(コード上はx座標とy座標は配列にはしていない)。その座標を、指示されたマスに石を置く関数cpu_placestoneに渡すことで、計算された
        最善手を打った後の盤面を格納するbanを得て、それを返り値として返す。
        評価値の最大値が負の場合、有効な位置がなかったということなのでパスを選択する。パスは、bestscorex, bestscoreyに-1を代入し、
        x < 0である場合に文字列"cpupass"を出力して現在ターン数を格納する変数turnsを1減少させることで実現する。この場合、盤面は変化しないので
        二次元配列banをそのまま返り値として返す。
    <v> (global bool)turns : その時点での経過ターン数(1 ~ 60)を格納するint値。ただしパスをしたターンはターン数としてカウントしない
    <v> (global bool)owaru1 : 先手プレイヤーがパスをしたターンと、その次の後手のターンのみTrueとなるbool変数。通常はFalse
    <v> (global bool)owaru1 : 後手プレイヤーがパスをしたターンと、その次の先手のターンのみTrueとなるbool変数。通常はFalse
        オセロのルール上、先手と後手が連続でパスを行った時点でゲーム終了となるので、owaru1 == True && owaru2 == Trueが発生した時点で
        ゲームは終了する。詳細な実装はmain関数の説明を参照
<f> ban = cpu_placestone1(ban) : 使用していない。cpuが先手の際に利用する。詳細な説明はoserou_forlearn.py の解説を参照
<f> ban = player_placestone(ban, gyou, retsu) : プレイヤーがクリックした位置の座標(gyou, retsu)に石を置けるかを判定し、
    石を置ける場合には置いた後の盤面banを返し、置けない場合はパスを行う。
<f> player-cpu = winner(ban) : ゲーム終了時の盤面banに対して勝敗判定を行い、試合結果をコマンドウィンドウに出力する。先手の黒石の数と後手の
    白石の数をそれぞれ線形探索し、先手(プレイヤー)の石が後手(cpu)の石より多ければ "winner : player"、 後手(cpu)の石が先手(プレイヤー)の石より
    多ければ "winner : cpu"と出力し、同点であれば"Draw"と表示する。その後にプレイヤーの石の数からcpuの石の数を引いた値を"score:"に続いて出力する。

<メインプログラムの解説> 
<v> (2Dlist) data : このプログラムでは使用しない。試合における各ターンの盤面の増減を格納する配列
<v> (int) turns : その時点での経過ターン数(1 ~ 60)を格納するint値。ただしパスをしたターンはターン数としてカウントしない
<v> (int) teban : その時点での経過ターン数(1 ~ )を格納するint値。パスをしたターンもターン数としてカウントする。
<v> (int) gyoudayo : プレイヤーが自分の手番の時間内で最後にクリック入力した座標のうちx座標を格納する。
<v> (int) gyoudayo : プレイヤーが自分の手番の時間内で最後にクリック入力した座標のうちy座標を格納する。
<v> (bool) owaru1 : 先手プレイヤーがパスをしたターンと、その次の後手のターンのみTrueとなるbool変数。通常はFalse
<v> (bool) owaru1 : 後手プレイヤーがパスをしたターンと、その次の先手のターンのみTrueとなるbool変数。通常はFalse
<v> (2Dlist) ban : オセロの盤面を格納する二次元配列。詳細はline 158 を参照　
<v> (int) a : プレイヤーの持ち時間。a 秒以内にプレイヤーは自分の手を入力する必要がある。プレイヤーから受け取る。
        ※ 1以上の整数値入力を想定。本来は入力値が正常か判定をすべきであるがその部分は未実装
<v> (int) suuji : このプログラムでは使用しない。試合結果の保存先のファイル名を指定する値
<v> (string) filename : このプログラムでは使用しない。試合結果の保存先のファイル名
<v> (bool) error :  このプログラムでは実際には不要だが、削除する場合にはプログラム l. 975 のwhile文を消すことが求められる。
    先手の手番が終了したかどうかを判定するbool値。wait_click関数が持ち時間a秒が経過するまでクリック入力の受付と画面の更新を
    高頻度のループで行い、a秒後に脱出するので、それが正常に行われた場合にerror = Falseとしてtry文を脱出する。
    ※この部分がwhile分とtry/except文を利用する必要は本来ないが、開発段階でクリック入力/コマンドラインからの入力があった時点で即座に入力待機
    を終了してプレイヤーの手番を終了するという仕様に対応させようとした名残で残っている。今後の開発で入力を受け付けた場合には残りの持ち時間を待たずに
    手番を終了したいというニーズが発生したときのために残している。wait_click関数内のafterを削除してerrorをグローバル変数にしてwait_click関数
    に渡し、クリックイベントが発生した時点でerror = Falseとすることでmain関数側のループを脱出するという方法で制限時間制を撤廃できる(詳細な実装は割愛)

動作の詳細：
1. 変数の初期化
2. 経過ターン数turns が 60ターン(オセロのマスが64マス、最初から埋まっているマスが4マスなので)以下の間、あるいは(bool) owaru1と(bool) owaru2が
    ともにFalseとなる、すなわちパスが2連続で行われるまでwhile文を反復する。
3. tebanが偶数の時はプレイヤーの入力をwait_click関数で受け付ける。具体的には、wait_click関数内部のclick_update関数が左クリックとclass Tkgui内部で
    紐づけられており、プレイヤーのクリック入力を受けとると呼び出され、プレイヤーのクリック座標を変数 gyou, retsuに格納し、またクリック位置に赤い石を表示する
    その間もwait_click関数内部でupdate関数を無限ループで回し、ウィンドウの更新を常に行う。
    a秒の手番が終了するとwait_click関数のupdate用無限ループが(bool) clk_okがFalseになることで脱出でき、l 980以降の実行に移る。手番が経過したので
    tebanとturnsを増加させ(パスをした場合はplayer_placestone内部でturns -= 1をしてあるので相殺される)、先手のターンを終了する。
    ban_imageを用いてその時点でのbanをウィンドウに画像として出力する。
4. tebanが奇数の時はcpuの手番であり、cpu_placestone2 関数を用いてその盤面における最も評価値の高い手をcpuの手として選択し実行する。
　　二次元配列dataにその時点での盤面の増減((oserou_log_learnフォルダ内のファイル)の解説を参照)を記録しているが、今回のプログラムでは使用していない
    ban_imageを用いてその時点でのbanをウィンドウに画像として出力する。
5. 3と4を繰り返し、2連続でパスが起きる、あるいはturns == 60となるすなわち盤上の全てのマスに石が置かれた時点でゲームを終了する。　
    winner_ban関数を用いて勝敗判定と結果の出力を行い、ゲームを終了する。

(oserou_forlearn.py)
oserou_vscpu.py で説明しなかった関数や変数、機能のみ説明する。
oserou_vscpu.py で使用するライブラリ：tkinter, csv, os, time, random

<f> score = score_calc2(ban) : 後手番における盤面の評価値を計算する。盤面の評価値は8行8列の二次元配列scoreに格納する。
    マスの評価値 = マスに割り振られた初期値(score_initialize) + 取れる石の数(score_count)
                     + あるランダムな値
    ランダムな値の設定方法：(平均0、標準偏差10の正規分布に従う乱数の絶対値) / sqrt(turns + 1) を整数値に丸めた値
    意図としては、turnsが小さいうちには各マスの評価値のランダムな変動が大きくなるので多様な盤面が学習でき、一方ターンが進むにつれて
    turnsが大きくなるとランダムな値の影響が小さくなるのでcpuはその盤面における最善手に近い手を指してくれる、という状況を目指した。
    盤面の多様性と、手の最適性を両立するためにターンが進むと減衰するランダム値を足しているということ。

<f> score = score_calc1(ban) : 先手番における盤面の評価値を計算する。その他の仕様はscore = score_calc2(ban)と同様
<f> ban = cpu_placestone2(ban) : 後手番において、評価値の最も高いマスをcpuの手とし、それを指した場合の状態に盤面を更新する。
    評価値の計算にはscore_learning関数ではなくscore_calc2関数を用いるよう変更されているので注意。
    score_learning関数を利用した場合は作者のローカル環境では重すぎてpython3が落ちた。
<f> ban = cpu_placestone1(ban) : 先手番において、評価値の最も高いマスをcpuの手とし、それを指した場合の状態に盤面を更新する。

<メインプログラムの詳細>
oserou_vscpu.py で説明しなかった関数や変数、機能のみ説明する。
<v> (int) suuji : 学習対象の各試合における増減を格納する先のファイル名を指定するための変数 実際はintではなくても動く
<v> (int) a : プレイヤーの持ち時間を示す変数だが今回は使用しない
<v> (string) filename : 学習対象の各試合の試合結果を保存するファイル名。oserou_log_learnフォルダ内のファイルを指定している。
<v> (_reader) lines : "oserou_log_learn/oserou_log_learn_incdec{}.csv".format(str(suuji)) ファイルの内容を読み込む先の変数
<v> (list[str]) line : linesの各行を格納する変数
<v> (string) ifilename : "data_learn/line{}.csv"、{}は1~38までの列に対応した値。各列における増減
    (列の増減の意味および格納方法は(oserou_log_learnフォルダ内のファイル)を参照)を記録しているファイルのファイル名
<v> (list) iline : 要素intの配列。第一要素が出現回数、それ以降の要素は各列における増減を格納
<v> (list) iline2 : 要素intの配列。各列における増減のみを格納し、出現回数は格納しない。ilineの第二要素以降と一致する
<v> (_reader) irows : "data_learn/line{}.csv"ファイルの内容を読み込む先の変数
<v> (list[str]) line : rowsの各行を格納する変数
<v> (int) ik : 現在何列目についての読み書きをしているのかを格納する変数
<v> (int) ia : 出現回数(iline[0])を出力して現在ターン数を格納する変数turnsを1減少させることで実現する。この場合、盤面は変化しないので

動作の詳細：
1. cpu同士の対戦を10試合行い、後手が勝った試合についてのみ、それらの試合の各ターンにおける全ての列の増減パターンをsuujiで指定されるファイル
    "oserou_log_learn/oserou_log_learn_incdec{}.csv"に格納
2. 1で試合内容を書き込んだ"oserou_log_learn/oserou_log_learn_incdec{}.csv"ファイルについて、試合・ターンごとに並んでいる各列の増減を
    列ごとに別々のファイル"data_learn/line{}.csv"に書き込む。この際、すでにその増減パターンが過去の学習データに出現していた、すなわち
    "data_learn/line{}.csv"内にすでにその増減パターン irow[1:len(irow)] が記録してあった場合は、その増減パターンに対応する列の
    一要素目に格納される出現回数を1増加させる。その増減パターンが過去の学習データに出現していない、すなわち
    "data_learn/line{}.csv"内にその増減パターンが記録されていない場合は、出現回数0回として
    "data_learn/line{}.csv"の末尾にその出現パターンを記録する。
    具体的には、 試合結果"oserou_log_learn/oserou_log_learn_incdec{}.csv"の各行lineについて、lineがすでに
    "data_learn/line{}.csv"の行irowから得られた増減パターンと一致しているかを探索する。ここで、"oserou_log_learn/oserou_log_learn_incdec{}.csv"
    ファイルは39行ごとにブロック化されており、各ブロックの最初の行はターン数が格納されているので、lineがその行を読み込んでいる場合は
    列の増減の比較はせずに飛ばすことが必要である。
3.　1~38の列について2を行い、それぞれの結果をilineに一時的に格納し、ilineで"data_learn/line{}.csv"を上書きする。
4. 学習終了の旨と試合結果が格納されたファイルとファイル名をコマンドウィンドウに出力する。

#Changelog
2022.08 初期バージョン




